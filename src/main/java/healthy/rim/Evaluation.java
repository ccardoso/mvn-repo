package healthy.rim;import java.io.Serializable;import java.util.Set;import java.util.HashSet;import java.util.Objects;import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;import healthy.rim.type.BooleanAdapter;import healthy.rim.type.CD;import javax.xml.bind.annotation.XmlType;/** * <p> * An Act of recognising and noting information about the subject, and whose * immediate and primary outcome (post-condition) is new data about a subject. * Evaluations often involve measurement or other elaborate methods of * investigation, but may also be simply assertive statements. * </p> * <p> * <i>Discussion:</i> Structurally, many evaluations are name-value-pairs, where * the Evaluation.code (inherited from Act) is the name and the Evaluation.value * is the value of the property. Such a construct is also known as a "variable" * (a named feature that can assume a value); hence, the Evaluation class is * always used to hold generic name-value-pairs or variables, even though the * variable valuation may not be the result of an elaborate evaluation method. * It may be a simple answer to a question or it may be an assertion or setting * of a parameter. * </p> * <p> * As with all Act statements, Evaluation statements describe what was done, and * in the case of Evaluations, this includes a description of what was actually * observed ("results" or "answers"); and those "results" or "answers" are part * of the evaluation and not split off Integero other objects. * </p> * <p> * An evaluation may consist of component evaluations each having their own * Evaluation.code and Evaluation.value. In this case, the composite evaluation * may not have an Evaluation.value for itself. For instance, a white blood cell * count consists of the sub-evaluations for the counts of the various * granulocytes, lymphocytes and other normal or abnormal blood cells (e.g., * blasts). The overall white blood cell count Evaluation itself may therefore * not have a value by itself (even though it could have one, e.g., the sum * total of white blood cells). Thus, as long as an Act is essentially an Act of * recognising and noting information about a subject, it is an Evaluation, * regardless of whether it has a simple value by itself or whether it has * sub-evaluations. * </p> * <p> * Even though evaluations are professional acts (see Act) and as such are * Integerentional actions, this does not require that every possible outcome of * an evaluation be pondered in advance of it being actually made. For instance, * differential white blood cell counts (WBC) rarely show blasts, but if they * do, this is part of the WBC evaluation even though blasts might not be * predefined in the structure of a normal WBC. * </p> * <p> * Diagnoses, findings, symptoms, etc. are also Evaluations. The Evaluation.code * (or the reference to the Evaluation definition) specifies the kind of * diagnosis (e.g. "chief complaInteger" or "discharge diagnosis") and the value * specifies the diagnosis code or symptom code. * </p> * * @author Yosvany Llerena Rodr√≠guez <yosvanyllr@gmail.com> * @since 20-Jun-2013 */@XmlRootElement(name = "Evaluation")@XmlAccessorType(XmlAccessType.FIELD)@XmlType(name = "Evaluation")public class Evaluation extends Act implements Serializable {    private static final long serialVersionUID = 7022013009924L;    @XmlElement(name = "valueNegationInd", defaultValue = "false")    @XmlJavaTypeAdapter(BooleanAdapter.class)    private Boolean valueNegationInd = false;    /**     * <p>     * A code that provides additional detail about the means or technique used     * to ascertain the evaluation.</p>     * <p>     * <i>Examples:</i> Blood pressure measurement method: arterial puncture vs.     * sphygmomanometer (Riva-Rocci), sitting vs. supine position, etc.     *     * </p>     * <p>     * <i>ConstraIntegers:</i> In all evaluations the method is already     * partially specified by the Act.code. In this case, the methodCode <b>need     * not</b>     * be used at all. The methodCode <b>may</b> still be used to identify this     * method more clearly in addition to what is implied from the Act.code.     * However, an information consumer system or process <b>should not</b>     * depend on this methodCode information for method detail that is implied     * by the Act.code.     * </p>     * <p>     * If the methodCode is used to express method detail that is also implied     * by the Act.code, the methodCode <b>must not</b> be in conflict with the     * implied method of the Act.code.     * </p>     * <p>     * <i>Discussion:</i> In all evaluations the method is already partially     * specified by simply knowing the kind of evaluation (evaluation     * definition, Act.code) and this implicit information about the method does     * not need to be specified in Evaluation.methodCode. For example, many     * LOINC codes are defined for specific methods as long as the method makes     * a practical difference in Interpretation. Thus, using LOINC, the     * difference between susceptibility studies using the "minimal inhibitory     * concentration" (MIC) or the "agar diffusion method" (Kirby-Baur) are     * specifically assigned different codes. The methodCode therefore is only     * an additional qualifier to specify what may not be known already from the     * Act.code.     * </p>     * <p>     * Also, some variances in methods may be tied to the particular device     * used. The methodCode should not be used to identify the specific device     * or test-kit material used in the evaluation. Such information about     * devices or test-kits should be associated with the evaluation as "device"     * participations.     * </p>     */     @XmlElement(name = "observationMethodCode", nillable = true)    private Set<CD> observationMethodCodes = new HashSet<CD>(0);    /**     * <p>     * One or more codes specifying a rough qualitative Interpretation of the     * evaluation, such as "normal", "abnormal", "below normal", "change up",     * "resistant", "susceptible", etc.     * </p>     * <p>     * <i>Discussion:</i> These Interpretation codes are sometimes called     * "abnormal flags", however, the judgement of normalcy is just one of the     * common rough Interpretations, and is often not relevant. For example, the     * susceptibility Interpretations are not about "normalcy", and for any     * evaluation of a pathologic condition, it does not make sense to state the     * normalcy, since pathologic conditions are never considered "normal."     * </p>     */     @XmlElement(name = "observationInterpretationCode", nillable = true)    private Set<CD> observationInterpretationCodes = new HashSet<CD>(0);    /**     * <p>     * A code specifying detail about the anatomical site or system that is the     * focus of the evaluation if this information is not already implied by the     * evaluation definition or Act.code.     * </p>     * <p>     * <i>ConstraIntegers:</i> The targetSiteCode value, if specified, <b>must     * not</b> conflict with what is implied about the target site or system     * from the evaluation definition and the Act.code.     * </p>     * <p>     * <i>Discussion:</i> Most evaluation target sites are implied by the     * evaluation definition and Act.code, or Evaluation.value. For example,     * "heart murmur" always has the heart as target. This attribute is used     * only when the evaluation target site needs to be refined, to distinguish     * right and left etc.     * </p>     * <p>     * If the subject of the Evaluation is something other than a human patient     * or animal, the attribute is used analogously to specify a structural     * landmark of the thing where the act focuses. For example, if the subject     * is a lake, the site could be inflow and outflow, etc. If the subject is a     * lymphatic node, "hilus," "periphery," etc. would still be valid target     * sites.     * </p>     */     @XmlElement(name = "observationTargetSiteCodes", nillable = true)    private Set<CD> observationTargetSiteCodes = new HashSet<CD>(0);    public Evaluation() {        super("OBSERVATION");    }    public Evaluation(Boolean valueNegationInd, Set<CD> observationMethodCodes,            Set<CD> observationInterpretationCodes, Set<CD> observationTargetSiteCodes) {        super("OBSERVATION");        this.valueNegationInd = valueNegationInd;        this.observationMethodCodes = observationMethodCodes;        this.observationInterpretationCodes = observationInterpretationCodes;        this.observationTargetSiteCodes = observationTargetSiteCodes;    }    public Boolean getValueNegationInd() {        return valueNegationInd;    }    public void setValueNegationInd(Boolean valueNegationInd) {        this.valueNegationInd = valueNegationInd;    }    /**     * see {@link Evaluation#observationMethodCodes}     *     * @return Set CD     */    public Set<CD> getEvaluationMethodCodes() {        return observationMethodCodes;    }    /**     * see {@link Evaluation#observationMethodCodes}     *     * @param observationMethodCodes     */    public void setEvaluationMethodCodes(Set<CD> observationMethodCodes) {        this.observationMethodCodes = observationMethodCodes;    }    /**     * see {@link Evaluation#observationInterpretationCodes}     *     * @return Set CD     */    public Set<CD> getEvaluationInterpretationCodes() {        return observationInterpretationCodes;    }    /**     * see {@link Evaluation#observationInterpretationCodes}     *     * @param observationInterpretationCodes     */    public void setEvaluationInterpretationCodes(Set<CD> observationInterpretationCodes) {        this.observationInterpretationCodes = new HashSet(observationInterpretationCodes);    }    /**     * see {@link Evaluation#observationTargetSiteCodes}     *     * @return Set CD     */    public Set<CD> getEvaluationTargetSiteCodes() {        return observationTargetSiteCodes;    }    /**     * see {@link Evaluation#observationTargetSiteCodes}     *     * @param observationTargetSiteCodes     */    public void setEvaluationTargetSiteCodes(Set<CD> observationTargetSiteCodes) {        this.observationTargetSiteCodes = new HashSet(observationTargetSiteCodes);    }    @Override    public int hashCode() {        int hash = 7;        hash = 89 * hash + Objects.hashCode(this.valueNegationInd);        hash = 89 * hash + Objects.hashCode(this.observationMethodCodes);        hash = 89 * hash + Objects.hashCode(this.observationInterpretationCodes);        hash = 89 * hash + Objects.hashCode(this.observationTargetSiteCodes);        return hash;    }    @Override    public boolean equals(Object obj) {        if (obj == null) {            return false;        }        if (getClass() != obj.getClass()) {            return false;        }        final Evaluation other = (Evaluation) obj;        if (!Objects.equals(this.valueNegationInd, other.valueNegationInd)) {            return false;        }        if (!Objects.equals(this.observationMethodCodes, other.observationMethodCodes)) {            return false;        }        if (!Objects.equals(this.observationInterpretationCodes, other.observationInterpretationCodes)) {            return false;        }        if (!Objects.equals(this.observationTargetSiteCodes, other.observationTargetSiteCodes)) {            return false;        }        return true;    }    @Override    public String toString() {        return "Evaluation{" + "internalId=" + this.getInternalId() + '}';    }}
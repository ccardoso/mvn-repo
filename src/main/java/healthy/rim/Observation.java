package healthy.rim;import java.io.Serializable;import java.util.Set;import java.util.HashSet;import java.util.Objects;import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;import healthy.rim.type.BooleanAdapter;import healthy.rim.type.CD;import javax.xml.bind.annotation.XmlType;/** * <p> * An Act of recognising and noting information about the subject, and whose * immediate and primary outcome (post-condition) is new data about a subject. * Observations often involve measurement or other elaborate methods of * investigation, but may also be simply assertive statements. * </p> * <p> * <i>Discussion:</i> Structurally, many observations are name-value-pairs, * where the Observation.code (inherited from Act) is the name and the * Observation.value is the value of the property. Such a construct is also * known as a "variable" (a named feature that can assume a value); hence, the * Observation class is always used to hold generic name-value-pairs or * variables, even though the variable valuation may not be the result of an * elaborate observation method. It may be a simple answer to a question or it * may be an assertion or setting of a parameter. * </p> * <p> * As with all Act statements, Observation statements describe what was done, * and in the case of Observations, this includes a description of what was * actually observed ("results" or "answers"); and those "results" or "answers" * are part of the observation and not split off Integero other objects. * </p> * <p> * An observation may consist of component observations each having their own * Observation.code and Observation.value. In this case, the composite * observation may not have an Observation.value for itself. For instance, a * white blood cell count consists of the sub-observations for the counts of the * various granulocytes, lymphocytes and other normal or abnormal blood cells * (e.g., blasts). The overall white blood cell count Observation itself may * therefore not have a value by itself (even though it could have one, e.g., * the sum total of white blood cells). Thus, as long as an Act is essentially * an Act of recognising and noting information about a subject, it is an * Observation, regardless of whether it has a simple value by itself or whether * it has sub-observations. * </p> * <p> * Even though observations are professional acts (see Act) and as such are * Integerentional actions, this does not require that every possible outcome of * an observation be pondered in advance of it being actually made. For * instance, differential white blood cell counts (WBC) rarely show blasts, but * if they do, this is part of the WBC observation even though blasts might not * be predefined in the structure of a normal WBC. * </p> * <p> * Diagnoses, findings, symptoms, etc. are also Observations. The * Observation.code (or the reference to the Observation definition) specifies * the kind of diagnosis (e.g. "chief complaInteger" or "discharge diagnosis") * and the value specifies the diagnosis code or symptom code. * </p> * * @author Yosvany Llerena Rodr√≠guez <yosvanyllr@gmail.com> * @since 20-Jun-2013 */@XmlRootElement(name = "Observation")@XmlAccessorType(XmlAccessType.FIELD)@XmlType(name = "Observation")public class Observation extends Act implements Serializable {    private static final long serialVersionUID = 7022013009924L;    @XmlElement(name = "valueNegationInd", defaultValue = "false")    @XmlJavaTypeAdapter(BooleanAdapter.class)    private Boolean valueNegationInd = false;    /**     * <p>     * A code that provides additional detail about the means or technique used     * to ascertain the observation.</p>     * <p>     * <i>Examples:</i> Blood pressure measurement method: arterial puncture vs.     * sphygmomanometer (Riva-Rocci), sitting vs. supine position, etc.     *     * </p>     * <p>     * <i>ConstraIntegers:</i> In all observations the method is already     * partially specified by the Act.code. In this case, the methodCode <b>need     * not</b> be used at all. The methodCode <b>may</b> still be used to     * identify this method more clearly in addition to what is implied from the     * Act.code. However, an information consumer system or process <b>should     * not</b> depend on this methodCode information for method detail that is     * implied by the Act.code.     * </p>     * <p>     * If the methodCode is used to express method detail that is also implied     * by the Act.code, the methodCode <b>must not</b> be in conflict with the     * implied method of the Act.code.     * </p>     * <p>     * <i>Discussion:</i> In all observations the method is already partially     * specified by simply knowing the kind of observation (observation     * definition, Act.code) and this implicit information about the method does     * not need to be specified in Observation.methodCode. For example, many     * LOINC codes are defined for specific methods as long as the method makes     * a practical difference in Interpretation. Thus, using LOINC, the     * difference between susceptibility studies using the "minimal inhibitory     * concentration" (MIC) or the "agar diffusion method" (Kirby-Baur) are     * specifically assigned different codes. The methodCode therefore is only     * an additional qualifier to specify what may not be known already from the     * Act.code.     * </p>     * <p>     * Also, some variances in methods may be tied to the particular device     * used. The methodCode should not be used to identify the specific device     * or test-kit material used in the observation. Such information about     * devices or test-kits should be associated with the observation as     * "device" participations.     * </p>     */     @XmlElement(name = "observationMethodCode", nillable = true)    private Set<CD> observationMethodCodes = new HashSet<CD>(0);    /**     * <p>     * One or more codes specifying a rough qualitative Interpretation of the     * observation, such as "normal", "abnormal", "below normal", "change up",     * "resistant", "susceptible", etc.     * </p>     * <p>     * <i>Discussion:</i> These Interpretation codes are sometimes called     * "abnormal flags", however, the judgement of normalcy is just one of the     * common rough Interpretations, and is often not relevant. For example, the     * susceptibility Interpretations are not about "normalcy", and for any     * observation of a pathologic condition, it does not make sense to state     * the normalcy, since pathologic conditions are never considered "normal."     * </p>     */     @XmlElement(name = "observationInterpretationCode", nillable = true)    private Set<CD> observationInterpretationCodes = new HashSet<CD>(0);    /**     * <p>     * A code specifying detail about the anatomical site or system that is the     * focus of the observation if this information is not already implied by     * the observation definition or Act.code.     * </p>     * <p>     * <i>ConstraIntegers:</i> The targetSiteCode value, if specified, <b>must     * not</b> conflict with what is implied about the target site or system     * from the observation definition and the Act.code.     * </p>     * <p>     * <i>Discussion:</i> Most observation target sites are implied by the     * observation definition and Act.code, or Observation.value. For example,     * "heart murmur" always has the heart as target. This attribute is used     * only when the observation target site needs to be refined, to distinguish     * right and left etc.     * </p>     * <p>     * If the subject of the Observation is something other than a human patient     * or animal, the attribute is used analogously to specify a structural     * landmark of the thing where the act focuses. For example, if the subject     * is a lake, the site could be inflow and outflow, etc. If the subject is a     * lymphatic node, "hilus," "periphery," etc. would still be valid target     * sites.     * </p>     */    @XmlElement(name = "observationTargetSiteCode", nillable = true)    private Set<CD> observationTargetSiteCodes = new HashSet<CD>(0);    public Observation() {        super("OBSERVATION");    }    public Observation(Boolean valueNegationInd, Set<CD> observationMethodCodes,            Set<CD> observationInterpretationCodes, Set<CD> observationTargetSiteCodes) {        super("OBSERVATION");        this.valueNegationInd = valueNegationInd;        this.observationMethodCodes = observationMethodCodes;        this.observationInterpretationCodes = observationInterpretationCodes;        this.observationTargetSiteCodes = observationTargetSiteCodes;    }    public Boolean getValueNegationInd() {        return valueNegationInd;    }    public void setValueNegationInd(Boolean valueNegationInd) {        this.valueNegationInd = valueNegationInd;    }    /**     * see {@link Observation#observationMethodCodes}     *     * @return Set CD     */    public Set<CD> getObservationMethodCodes() {        return observationMethodCodes;    }    /**     * see {@link Observation#observationMethodCodes}     *     * @param observationMethodCodes     */    public void setObservationMethodCodes(Set<CD> observationMethodCodes) {        this.observationMethodCodes = new HashSet(observationMethodCodes);    }    /**     * see {@link Observation#observationInterpretationCodes}     *     * @return Set CD     */    public Set<CD> getObservationInterpretationCodes() {        return observationInterpretationCodes;    }    /**     * see {@link Observation#observationInterpretationCodes}     *     * @param observationInterpretationCodes     */    public void setObservationInterpretationCodes(Set<CD> observationInterpretationCodes) {        this.observationInterpretationCodes = new HashSet(observationInterpretationCodes);    }    /**     * see {@link Observation#observationTargetSiteCodes}     *     * @return Set CD     */    public Set<CD> getObservationTargetSiteCodes() {        return observationTargetSiteCodes;    }    /**     * see {@link Observation#observationTargetSiteCodes}     *     * @param observationTargetSiteCodes     */    public void setObservationTargetSiteCodes(Set<CD> observationTargetSiteCodes) {        this.observationTargetSiteCodes = new HashSet(observationTargetSiteCodes);    }    @Override    public int hashCode() {        int hash = 7;        hash = 61 * hash + Objects.hashCode(this.valueNegationInd);        hash = 61 * hash + Objects.hashCode(this.observationMethodCodes);        hash = 61 * hash + Objects.hashCode(this.observationInterpretationCodes);        hash = 61 * hash + Objects.hashCode(this.observationTargetSiteCodes);        return hash;    }    @Override    public boolean equals(Object obj) {        if (obj == null) {            return false;        }        if (getClass() != obj.getClass()) {            return false;        }        final Observation other = (Observation) obj;        if (!Objects.equals(this.valueNegationInd, other.valueNegationInd)) {            return false;        }        if (!Objects.equals(this.observationMethodCodes, other.observationMethodCodes)) {            return false;        }        if (!Objects.equals(this.observationInterpretationCodes, other.observationInterpretationCodes)) {            return false;        }        if (!Objects.equals(this.observationTargetSiteCodes, other.observationTargetSiteCodes)) {            return false;        }        return true;    }    @Override    public String toString() {        return "Observation{" + "internalId=" + this.getInternalId() + '}';    }}